<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.10.0/font/bootstrap-icons.min.css"
      rel="stylesheet"
    />
    <title>Post - Study Group</title>
    <style>
      :root {
        --primary-color: #4caf50;
        --primary-hover: #388e3c;
        --primary-light: #e8f5e9;
        --secondary-color: #2196f3;
        --secondary-light: #e3f2fd;
        --warning-color: #ff9800;
        --danger-color: #f44336;
        --dark-text: #333;
        --medium-text: #666;
        --light-text: #888;
        --border-light: #e0e0e0;
        --background-light: #f8f9fa;
        --shadow-light: rgba(0, 0, 0, 0.1);
        --shadow-medium: rgba(0, 0, 0, 0.15);
        --white: #ffffff;
        --transition: all 0.3s ease;
      }
      
      body {
        font-family: "Arial", sans-serif;
        background: var(--background-light);
        overflow-x: hidden;
        color: var(--dark-text);
        transition: var(--transition);
      }
      
      /* Dark Mode Styles */
      body.dark-mode {
        --dark-text: #e0e0e0;
        --medium-text: #bbb;
        --light-text: #999;
        --background-light: #1a1a1a;
        --border-light: #333;
        --shadow-light: rgba(0, 0, 0, 0.2);
        --shadow-medium: rgba(0, 0, 0, 0.3);
        --white: #2a2a2a;
        background: #1a1a1a;
        color: var(--dark-text);
      }

      /* Updated dark mode sidebar styles */
      body.dark-mode .sidebar {
        background: linear-gradient(135deg, #2e5d31 0%, #4a7c4f 100%);
      }

      body.dark-mode .sidebar-brand {
        color: white;
      }

      body.dark-mode .sidebar-item {
        color: white;
      }

      body.dark-mode .sidebar-item:hover,
      body.dark-mode .sidebar-item.active {
        background: rgba(255, 255, 255, 0.1);
        border-left-color: white;
        color: white;
      }

      body.dark-mode .top-nav {
        background: #2a2a2a;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      }

      body.dark-mode .page-title {
        color: var(--dark-text);
      }

      body.dark-mode .main-content { 
        background: #1a1a1a;
      }

      body.dark-mode .menu-toggle {
        color: var(--medium-text);
      }

      body.dark-mode .menu-toggle:hover {
        background: #333;
      }
      
      body.dark-mode .theme-toggle {
        color: var(--dark-text);
      }

      body.dark-mode .theme-toggle:hover {
        background: #333;
      }
      
      body.dark-mode .breadcrumbs {
        color: var(--medium-text);
      }
      
      body.dark-mode .breadcrumbs a {
        color: var(--primary-color);
      }
      
      body.dark-mode .back-link {
        color: var(--primary-color);
      }
      
      body.dark-mode .back-link:hover {
        color: var(--primary-hover);
      }
      
      body.dark-mode .post-header,
      body.dark-mode .comments-section {
        background: #2a2a2a;
        box-shadow: 0 3px 15px rgba(0,0,0,0.2);
      }
      
      body.dark-mode .post-title {
        color: var(--primary-color);
      }
      
      body.dark-mode .post-meta,
      body.dark-mode .sort-label {
        color: var(--medium-text);
      }
      
      body.dark-mode .post-content,
      body.dark-mode .comment-content {
        color: var(--dark-text);
      }
      
      body.dark-mode .author-avatar,
      body.dark-mode .comment-avatar {
        background: #333;
        color: var(--primary-color);
      }
      
      body.dark-mode .comments-title {
        color: var(--primary-color);
      }
      
      body.dark-mode .sort-dropdown {
        background: #333;
        color: var(--dark-text);
        border-color: #444;
      }
      
      body.dark-mode .sort-dropdown:focus {
        border-color: var(--primary-color);
      }
      
      body.dark-mode .comment {
        border-color: #333;
      }
      
      body.dark-mode .comment:hover {
        background-color: #222;
      }
      
      body.dark-mode .comment .comment {
        border-left-color: #333;
      }
      
      body.dark-mode .comment-author {
        color: var(--primary-color);
      }
      
      body.dark-mode .comment-meta {
        color: var(--light-text);
      }
      
      body.dark-mode .comment-deleted {
        color: var(--medium-text);
      }
      
      body.dark-mode .reply-btn,
      body.dark-mode .edit-btn,
      body.dark-mode .delete-btn,
      body.dark-mode .collapse-btn {
        color: var(--medium-text);
      }
      
      body.dark-mode .reply-btn {
        color: var(--primary-color);
      }
      
      body.dark-mode .reply-btn:hover,
      body.dark-mode .edit-btn:hover {
        background-color: #333;
      }
      
      body.dark-mode .delete-btn:hover {
        background-color: rgba(211, 47, 47, 0.2);
      }
      
      body.dark-mode .quick-comment-input,
      body.dark-mode .reply-input {
        background: #333;
        border-color: #444;
        color: var(--dark-text);
      }
      
      body.dark-mode .quick-comment-input::placeholder,
      body.dark-mode .reply-input::placeholder {
        color: var(--light-text);
      }
      
      body.dark-mode .quick-comment-input:focus,
      body.dark-mode .reply-input:focus {
        background: #3a3a3a;
        border-color: var(--primary-color);
      }

      body.dark-mode .reply-form {
        background: #2a2a2a;
        border-color: #444;
      }

      body.dark-mode .nesting-indicator {
        border-color: #444;
      }
      
      body.dark-mode .reply-path {
        background-color: #333;
        color: #aaa;
      }
      
      /* Theme toggle button */
      .theme-toggle {
        background: none;
        border: none;
        font-size: 18px;
        color: var(--medium-text);
        cursor: pointer;
        padding: 8px;
        border-radius: 50%;
        transition: all 0.3s ease;
      }
      .theme-toggle:hover {
        background: var(--background-light);
        transform: scale(1.1);
      }
      
      .nav-right {
        display: flex;
        align-items: center;
      }
      
      /* Updated sidebar CSS */
      .sidebar {
        position: fixed;
        left: -280px;
        top: 0;
        width: 280px;
        height: 100vh;
        background: linear-gradient(135deg, #4caf50 0%, #66bb6a 100%);
        transition: left 0.3s ease;
        z-index: 1000;
        box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      }
      .sidebar.open {
        left: 0;
      }
      .sidebar-header {
        padding: 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .sidebar-brand {
        color: white;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .sidebar-menu {
        padding: 20px 0;
      }
      .sidebar-item {
        display: block;
        color: white;
        text-decoration: none;
        padding: 15px 20px;
        transition: all 0.3s ease;
        border-left: 3px solid transparent;
      }
      .sidebar-item:hover,
      .sidebar-item.active {
        background: rgba(255, 255, 255, 0.1);
        border-left-color: white;
        color: white;
      }
      .sidebar-item i {
        width: 20px;
        margin-right: 10px;
      }
      .sidebar-footer {
        position: absolute;
        bottom: 20px;
        width: 100%;
        padding: 0 20px;
      }
      .user-info {
        display: flex;
        align-items: center;
        gap: 10px;
        color: white;
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .user-info:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
      }
      .user-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--primary-color);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
      }

      .main-content {
        margin-left: 0;
        transition: margin-left 0.3s ease;
        min-height: 100vh;
        background: var(--background-light);
      }
      .main-content.shifted {
        margin-left: 280px;
      }

      .container-wrapper {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px 20px 20px;
      }

      .top-nav {
        background: white;
        padding: 15px 30px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: sticky;
        top: 0;
        z-index: 100;
      }
      .nav-left {
        display: flex;
        align-items: center;
        gap: 20px;
      }
      .menu-toggle {
        background: none;
        border: none;
        font-size: 20px;
        color: #666;
        cursor: pointer;
        padding: 8px;
        border-radius: 5px;
        transition: all 0.3s ease;
      }
      .menu-toggle:hover {
        background: #f0f0f0;
      }
      .page-title {
        font-size: 24px;
        font-weight: bold;
        color: #333;
      }

      .breadcrumbs {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #666;
        margin: 15px 0 5px 0;
        flex-wrap: wrap;
      }
      .breadcrumbs a {
        color: #388e3c;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
      }
      .breadcrumbs a:hover {
        text-decoration: underline;
      }
      .breadcrumb-separator {
        color: #999;
        font-size: 12px;
      }

      .back-link {
        font-size: 16px;
        color: #388e3c;
        background: none;
        border: none;
        text-decoration: none;
        cursor: pointer;
        padding: 0;
        margin-bottom: 10px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s;
      }
      .back-link:hover {
        color: #2e7d32;
        text-decoration: underline;
      }

      .post-header {
        margin: 10px 0 15px 0;
        background: white;
        border-radius: 15px;
        padding: 20px 25px;
        box-shadow: 0 2px 10px rgba(76, 175, 80, 0.1);
        position: relative;
      }
      .post-title {
        font-size: 22px;
        font-weight: bold;
        color: #388e3c;
        margin-bottom: 12px;
      }
      .post-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 15px;
        font-size: 14px;
        color: #666;
      }
      .post-meta-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .post-author {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .author-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: #e8f5e9;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #388e3c;
        font-size: 14px;
        font-weight: bold;
      }
      .post-content {
        font-size: 16px;
        color: #333;
        margin-bottom: 15px;
        line-height: 1.5;
        white-space: pre-wrap;
      }

      /* Simplified comments section */
      .comments-section {
        background: white;
        border-radius: 15px;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.08);
        margin-bottom: 20px;
        padding: 15px 20px;
      }
      .comments-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .comments-title {
        font-size: 18px;
        font-weight: bold;
        color: #256029;
        margin: 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .comments-count {
        color: #666;
        font-weight: normal;
        font-size: 14px;
      }
      .comments-sort {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .sort-label {
        font-size: 14px;
        color: #666;
      }
      .sort-dropdown {
        padding: 5px 12px;
        border: 1px solid #ddd;
        border-radius: 20px;
        background: white;
        font-size: 14px;
        color: #333;
        cursor: pointer;
      }
      .sort-dropdown:focus {
        outline: none;
        border-color: #4caf50;
      }

      /* Improved comment styling with better nesting indicators */
      .comment-list {
        position: relative;
      }
      .comment {
        border-bottom: 1px solid #f0f0f0;
        padding: 10px 0;
        margin-left: 0;
        position: relative;
        transition: all 0.2s;
      }
      .comment:last-child {
        border-bottom: none;
      }
      .comment:hover {
        background-color: #f9f9f9;
      }

      /* Comment threading styles */
      .comment .comment {
        border-bottom: none;
        border-left: 2px solid #e8f5e9;
        margin-left: 20px;
        padding: 8px 0 3px 12px;
      }
      
      /* Better visual indicators for nesting levels */
      .comment .comment .comment {
        margin-left: 15px;
        border-left-color: #a5d6a7; /* Darker green */
      }
      
      .comment .comment .comment .comment {
        margin-left: 12px;
        border-left-color: #66bb6a; /* Even darker green */
      }
      
      /* After level 4, keep same indentation but use dotted line */
      .comment .comment .comment .comment .comment {
        margin-left: 10px;
        border-left-style: dotted;
        border-left-color: #4caf50;
      }

      .comment-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 5px;
      }
      .comment-author-info {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .comment-avatar {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: #e8f5e9;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #388e3c;
        font-size: 12px;
        font-weight: bold;
      }
      .comment-user {
        display: flex;
        flex-direction: column;
        line-height: 1.2;
      }
      .comment-author {
        font-weight: 600;
        color: #388e3c;
        font-size: 13px;
      }
      .comment-meta {
        font-size: 11px;
        color: #999;
      }
      .comment-meta .edited-indicator {
        margin-left: 4px;
        font-style: italic;
        font-size: 10px;
      }

      .comment-body {
        padding-left: 36px;
      }
      .comment-content {
        font-size: 14px;
        color: #333;
        margin-bottom: 5px;
        line-height: 1.4;
        white-space: pre-wrap;
      }
      .comment-deleted {
        font-style: italic;
        color: #999;
      }

      .comment-actions {
        display: flex;
        gap: 10px;
        margin-top: 3px;
      }
      .reply-btn,
      .edit-btn,
      .delete-btn {
        background: none;
        border: none;
        font-size: 12px;
        cursor: pointer;
        padding: 2px 5px;
        border-radius: 3px;
        color: #666;
        display: inline-flex;
        align-items: center;
        gap: 3px;
        transition: all 0.2s;
      }
      .reply-btn {
        color: #388e3c;
      }
      .reply-btn:hover,
      .edit-btn:hover {
        background-color: #f0f0f0;
        color: #2e7d32;
      }
      .delete-btn:hover {
        background-color: #ffebee;
        color: #d32f2f;
      }

      .collapse-btn {
        background: none;
        border: none;
        color: #666;
        font-size: 12px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 3px;
        padding: 2px 5px;
        border-radius: 3px;
        transition: all 0.2s;
      }
      .collapse-btn:hover {
        background-color: #f0f0f0;
        color: #388e3c;
      }
      .collapsed .comment-body {
        display: none;
      }
      .collapsed .comment-actions {
        display: none;
      }
      .collapsed .comment .comment {
        display: none;
      }

      /* Improved inline reply form with larger textarea */
      .reply-form {
        margin: 10px 0 12px 36px;
        display: flex;
        align-items: flex-start;
        gap: 10px;
        background: #f9f9f9;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #eee;
        display: none;
      }
      .reply-form.active {
        display: flex;
      }
      .reply-input {
        flex: 1;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px 12px;
        font-size: 14px;
        background: white;
        resize: none;
        min-height: 80px; /* Much taller textarea */
        width: 100%;
        line-height: 1.5;
      }
      .reply-input:focus {
        outline: none;
        border-color: #4caf50;
        box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.1);
      }
      .reply-btn-group {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        justify-content: flex-end;
      }
      .reply-submit,
      .reply-cancel {
        border: none;
        border-radius: 6px;
        padding: 6px 12px;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .reply-submit {
        background: #4caf50;
        color: white;
      }
      .reply-submit:hover {
        background: #388e3c;
      }
      .reply-cancel {
        background: #f1f1f1;
        color: #666;
      }
      .reply-cancel:hover {
        background: #e0e0e0;
      }
      
      /* Main comment form */
      .create-comment-container {
        margin-top: 10px;
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }
      .quick-comment-form {
        flex: 1;
        position: relative;
      }
      .quick-comment-input {
        width: 100%;
        border: 1px solid #ddd;
        border-radius: 20px;
        padding: 8px 12px;
        font-size: 14px;
        transition: all 0.2s;
        background: #f9f9f9;
        resize: none;
        min-height: 40px;
      }
      .quick-comment-input:focus {
        outline: none;
        border-color: #4caf50;
        background: white;
      }

      .create-comment-btn {
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 20px;
        padding: 8px 16px;
        font-size: 14px;
        font-weight: 500;
        margin-top: 10px;
        transition: all 0.3s;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .create-comment-btn:hover {
        background: #388e3c;
      }

      .post-reactions {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 10px;
      }
      .reaction-btn {
        background: #f5f5f5;
        border: 1px solid #eee;
        border-radius: 20px;
        padding: 6px 12px;
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 14px;
        color: #555;
      }
      .reaction-btn:hover {
        background: #e8f5e9;
        color: #388e3c;
      }
      .reaction-btn.active {
        background: #e8f5e9;
        color: #388e3c;
        border-color: #a5d6a7;
      }
      .reaction-count {
        font-weight: 500;
      }

      .empty-comments {
        text-align: center;
        padding: 20px;
      }
      .empty-icon {
        font-size: 32px;
        color: #ccc;
        margin-bottom: 10px;
      }
      .empty-text {
        font-size: 15px;
        color: #888;
      }

      .loader {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      .loader-spinner {
        width: 30px;
        height: 30px;
        border: 2px solid rgba(76, 175, 80, 0.3);
        border-radius: 50%;
        border-top-color: #4caf50;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Improved reply indicators */
      .replying-to {
        font-size: 12px;
        color: #388e3c;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      
      /* New reply path indicator for deep nesting */
      .reply-path {
        margin-bottom: 5px;
        font-size: 11px;
        color: #777;
        background-color: #f5f5f5;
        padding: 3px 8px;
        border-radius: 4px;
        display: inline-flex;
        align-items: center;
        gap: 3px;
      }
      
      .reply-path i {
        font-size: 10px;
        color: #999;
      }

      @media (max-width: 900px) {
        .post-header {
          padding: 15px;
        }
        .comments-section {
          padding: 15px;
        }
      }
      @media (max-width: 768px) {
        .main-content.shifted {
          margin-left: 0;
        }
        .sidebar {
          left: -280px !important;
        }
        .sidebar.open {
          left: 0 !important;
        }
        .post-title {
          font-size: 18px;
        }
        .post-meta {
          flex-direction: column;
          gap: 8px;
        }
        .comments-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }
        .comment-body {
          padding-left: 0;
          margin-top: 5px;
        }
        .reply-form {
          margin-left: 10px;
        }
      }
      @media (max-width: 500px) {
        .post-title {
          font-size: 16px;
        }
        .comments-title {
          font-size: 16px;
        }
        .create-comment-btn {
          width: 100%;
          justify-content: center;
        }
        .comment-actions {
          flex-wrap: wrap;
        }
        .container-wrapper {
          padding: 0 10px 15px 10px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-brand">
          <i class="bi bi-book"></i>
          StudyGroup
        </div>
      </div>
      <nav class="sidebar-menu">
        <a href="dashboard.html" class="sidebar-item"
          ><i class="bi bi-house"></i>Dashboard</a
        >
        <a href="profile.html" class="sidebar-item"
          ><i class="bi bi-person"></i>Profile</a
        >
        <a href="study-rooms.html" class="sidebar-item"
          ><i class="bi bi-door-open"></i>Study Rooms</a
        >
        <a href="resources.html" class="sidebar-item"
          ><i class="bi bi-folder"></i>Resources</a
        >
        <a href="discussion.html" class="sidebar-item active"
          ><i class="bi bi-chat-dots"></i>Discussion Forum</a
        >
        <a href="report.html" class="sidebar-item"
          ><i class="bi bi-graph-up"></i>Report</a
        >
      </nav>
      <div class="sidebar-footer">
        <div
          class="user-info"
          onclick="goToProfile()"
          style="cursor: pointer; transition: all 0.3s ease"
        >
          <div class="user-avatar" id="sidebarUserAvatar">DP</div>
          <div>
            <div
              style="font-weight: bold; font-size: 14px"
              id="sidebarUsername"
            >
              DanePascual
            </div>
            <div style="font-size: 12px; opacity: 0.8">BSIT</div>
          </div>
        </div>
      </div>
    </div>
    <!-- Main Content -->
    <div class="main-content" id="mainContent">
      <!-- Top Navigation -->
      <div class="top-nav">
        <div class="nav-left">
          <button class="menu-toggle" id="menuToggle">
            <i class="bi bi-list"></i>
          </button>
          <h1 class="page-title">Discussion</h1>
        </div>
        <div class="nav-right">
          <button class="theme-toggle" id="themeToggle" title="Toggle theme">
            <i class="bi bi-moon"></i>
          </button>
        </div>
      </div>

      <div class="container-wrapper">
        <!-- Breadcrumbs -->
        <div class="breadcrumbs" id="breadcrumbs">
          <a href="discussion.html"
            ><i class="bi bi-house-door"></i> Forum</a
          >
          <span class="breadcrumb-separator"
            ><i class="bi bi-chevron-right"></i
          ></span>
          <a href="#" id="topicBreadcrumb">Topic</a>
          <span class="breadcrumb-separator"
            ><i class="bi bi-chevron-right"></i
          ></span>
          <span id="postBreadcrumb">Post</span>
        </div>

        <!-- Post Header -->
        <div class="post-header" id="postHeader">
          <button class="back-link" id="backToTopic">
            <i class="bi bi-arrow-left"></i> Back to Topic
          </button>
          <div class="post-title" id="postTitle">Post Title</div>
          <div class="post-meta">
            <div class="post-author" id="postAuthor">
              <div class="author-avatar" id="postAuthorAvatar">A</div>
              <span id="postAuthorName">Anonymous</span>
            </div>
            <div class="post-meta-item">
              <i class="bi bi-clock"></i>
              <span id="postTime">July 1, 2023</span>
            </div>
            <div
              class="post-meta-item"
              id="postEditedContainer"
              style="display: none"
            >
              <i class="bi bi-pencil"></i>
              <span>Edited</span>
            </div>
          </div>
          <div class="post-content" id="postContent">Loading content...</div>

          <div class="post-reactions">
            <button class="reaction-btn" id="likeBtn">
              <i class="bi bi-hand-thumbs-up"></i>
              <span class="reaction-count" id="likeCount">0</span>
            </button>
          </div>
        </div>

        <!-- Comments Section -->
        <div class="comments-section" id="commentsSection">
          <div class="comments-header">
            <h2 class="comments-title">
              <i class="bi bi-chat-square-text"></i>
              Comments <span class="comments-count" id="commentsCount"></span>
            </h2>
            <div class="comments-sort">
              <span class="sort-label">Sort by:</span>
              <select class="sort-dropdown" id="commentSortDropdown">
                <option value="newest">Newest</option>
                <option value="oldest">Oldest</option>
                <option value="popular">Popular</option>
              </select>
            </div>
          </div>

          <div id="commentsList" class="comment-list">
            <!-- Comments will be rendered here -->
            <div class="loader">
              <div class="loader-spinner"></div>
            </div>
          </div>

          <div class="create-comment-container">
            <div class="comment-avatar" id="currentUserAvatar">DP</div>
            <div class="quick-comment-form">
              <textarea
                class="quick-comment-input"
                id="quickCommentInput"
                placeholder="Write a comment..."
                rows="1"
              ></textarea>
            </div>
          </div>

          <button class="create-comment-btn" id="createCommentBtn">
            <i class="bi bi-send"></i> Post Comment
          </button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script>
      // Current session information
      const CURRENT_SESSION = {
        utcTime: "2025-08-31 12:59:19", // Updated UTC time
        user: "DanePascual",
        timezone: "UTC"
      };

      // Current user ID (normally from auth system)
      const CURRENT_USER_ID = "user_dane_pascual"; 
      const CURRENT_USER_NAME = CURRENT_SESSION.user;
      const CURRENT_USER_INITIALS = "DP";

      // Track active reply form
      let activeReplyForm = null;
      
      // Track expanded comment threads to maintain state
      let expandedThreads = new Set();
      
      // Track the scroll position
      let lastScrollPosition = 0;

      // Theme management
      function initializeTheme() {
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;
        
        // Load saved theme from localStorage
        const savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') {
          body.classList.add('dark-mode');
          themeToggle.innerHTML = '<i class="bi bi-sun"></i>';
        }
        
        // Add toggle event
        themeToggle.addEventListener('click', () => {
          body.classList.toggle('dark-mode');
          const isDark = body.classList.contains('dark-mode');
          themeToggle.innerHTML = isDark ? '<i class="bi bi-sun"></i>' : '<i class="bi bi-moon"></i>';
          localStorage.setItem('theme', isDark ? 'dark' : 'light');
        });
      }

      // Sidebar Toggle
      const menuToggle = document.getElementById("menuToggle");
      const sidebar = document.getElementById("sidebar");
      const mainContent = document.getElementById("mainContent");
      menuToggle.addEventListener("click", function () {
        sidebar.classList.toggle("open");
        mainContent.classList.toggle("shifted");
      });
      document.addEventListener("click", function (event) {
        if (window.innerWidth <= 768) {
          if (
            !sidebar.contains(event.target) &&
            !menuToggle.contains(event.target)
          ) {
            sidebar.classList.remove("open");
            mainContent.classList.remove("shifted");
          }
        }
      });
      function goToProfile() {
        window.location.href = "profile.html";
      }

      // --- Utility functions ---
      function getIdsFromUrl() {
        const params = new URLSearchParams(window.location.search);
        return {
          topicId: params.get("topic"),
          postId: params.get("post"),
        };
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      // Format relative time
      function formatRelativeTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffSec = Math.round(diffMs / 1000);
        const diffMin = Math.round(diffSec / 60);
        const diffHour = Math.round(diffMin / 60);
        const diffDay = Math.round(diffHour / 24);

        if (diffSec < 60) return "just now";
        if (diffMin < 60)
          return `${diffMin} min${diffMin !== 1 ? "s" : ""} ago`;
        if (diffHour < 24)
          return `${diffHour} hr${diffHour !== 1 ? "s" : ""} ago`;
        if (diffDay < 7) return `${diffDay} day${diffDay !== 1 ? "s" : ""} ago`;

        // If older than a week, show date
        const options = { year: "numeric", month: "short", day: "numeric" };
        return date.toLocaleDateString(undefined, options);
      }

      // Generate initials from username
      function getInitials(name) {
        if (!name) return "?";
        return name
          .split(" ")
          .map((part) => part.charAt(0))
          .join("")
          .toUpperCase()
          .substring(0, 2);
      }

      // Format text with basic markdown
      function formatTextWithMarkdown(text) {
        if (!text) return "";

        // Escape HTML first to prevent XSS
        const escaped = text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");

        // Format bold text
        let formatted = escaped.replace(
          /\*\*(.*?)\*\*/g,
          "<strong>$1</strong>"
        );

        // Format italic text
        formatted = formatted.replace(/_(.*?)_/g, "<em>$1</em>");

        // Format code blocks
        formatted = formatted.replace(/`(.*?)`/g, "<code>$1</code>");

        // Convert URLs to links
        formatted = formatted.replace(
          /(https?:\/\/[^\s]+)/g,
          '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
        );

        return formatted;
      }
      
      // Get comment path for deep nesting
      function getCommentPath(comments, commentId) {
        if (!commentId) return [];
        
        const comment = comments.find(c => c.id === commentId);
        if (!comment) return [];
        
        if (!comment.parentId) {
          return [comment.author];
        } else {
          const parentPath = getCommentPath(comments, comment.parentId);
          return [...parentPath, comment.author];
        }
      }

      // --- Backend API simulation ---

      // Get topic info for breadcrumbs
      async function getTopic(topicId) {
        await delay(50);
        const topics = JSON.parse(localStorage.getItem("topics") || "[]");
        return topics.find((t) => t.id == topicId);
      }

      // Get post by id
      async function getPost(topicId, postId) {
        await delay(50);
        const posts = JSON.parse(
          localStorage.getItem("posts_" + topicId) || "[]"
        );

        // Update view count for this post
        const postIndex = posts.findIndex((p) => p.id == postId);
        if (postIndex !== -1) {
          posts[postIndex].viewCount = (posts[postIndex].viewCount || 0) + 1;
          localStorage.setItem("posts_" + topicId, JSON.stringify(posts));
        }

        return posts.find((p) => p.id == postId);
      }

      // Get all comments
      async function getComments(topicId, postId, sort = "newest") {
        await delay(50);
        let comments = JSON.parse(
          localStorage.getItem("comments_" + topicId + "_" + postId) || "[]"
        );

        // Apply sorting
        switch (sort) {
          case "newest":
            comments.sort((a, b) => new Date(b.created) - new Date(a.created));
            break;
          case "oldest":
            comments.sort((a, b) => new Date(a.created) - new Date(b.created));
            break;
          case "popular":
            comments.sort((a, b) => (b.likes || 0) - (a.likes || 0));
            break;
        }

        return comments;
      }

      // Create a comment
      async function createComment(
        topicId,
        postId,
        { content, author, parentId }
      ) {
        await delay(100);
        const commentsKey = "comments_" + topicId + "_" + postId;
        const comments = JSON.parse(localStorage.getItem(commentsKey) || "[]");
        const now = new Date();
        const comment = {
          id: Date.now().toString(),
          content,
          author: author || CURRENT_USER_NAME,
          created: now.toISOString(),
          lastEdited: null,
          parentId: parentId || null,
          userId: CURRENT_USER_ID,
          likes: 0,
          liked_by: [],
        };
        comments.push(comment);
        localStorage.setItem(commentsKey, JSON.stringify(comments));

        // Update comment count in the post
        const posts = JSON.parse(
          localStorage.getItem("posts_" + topicId) || "[]"
        );
        const postIndex = posts.findIndex((p) => p.id == postId);
        if (postIndex !== -1) {
          posts[postIndex].commentCount =
            (posts[postIndex].commentCount || 0) + 1;
          localStorage.setItem("posts_" + topicId, JSON.stringify(posts));
        }

        return comment;
      }

      // Update comment content - renamed to avoid naming conflicts
      async function updateCommentContent(topicId, postId, commentId, newContent) {
        await delay(100);
        const commentsKey = "comments_" + topicId + "_" + postId;
        const comments = JSON.parse(localStorage.getItem(commentsKey) || "[]");
        const comment = comments.find((c) => c.id === commentId);

        if (!comment) return null;
        if (comment.userId !== CURRENT_USER_ID) return null;

        comment.content = newContent;
        comment.lastEdited = new Date().toISOString();
        localStorage.setItem(commentsKey, JSON.stringify(comments));
        return comment;
      }

      // Remove comment - renamed to avoid naming conflicts
      async function removeComment(topicId, postId, commentId) {
        await delay(100);
        const commentsKey = "comments_" + topicId + "_" + postId;
        let comments = JSON.parse(localStorage.getItem(commentsKey) || "[]");
        const comment = comments.find((c) => c.id === commentId);

        if (!comment) return false;
        if (comment.userId !== CURRENT_USER_ID) return false;

        // Check if comment has replies
        const hasReplies = comments.some((c) => c.parentId === commentId);

        if (hasReplies) {
          comment.content = "[Comment deleted]";
          comment.isDeleted = true;
        } else {
          comments = comments.filter((c) => c.id !== commentId);

          // Update comment count in the post
          const posts = JSON.parse(
            localStorage.getItem("posts_" + topicId) || "[]"
          );
          const postIndex = posts.findIndex((p) => p.id == postId);
          if (postIndex !== -1 && posts[postIndex].commentCount > 0) {
            posts[postIndex].commentCount--;
            localStorage.setItem("posts_" + topicId, JSON.stringify(posts));
          }
        }

        localStorage.setItem(commentsKey, JSON.stringify(comments));
        return true;
      }

      // Like a post
      async function likePost(topicId, postId) {
        await delay(50);
        const posts = JSON.parse(
          localStorage.getItem("posts_" + topicId) || "[]"
        );
        const postIndex = posts.findIndex((p) => p.id == postId);

        if (postIndex === -1) return null;

        if (!posts[postIndex].likes) {
          posts[postIndex].likes = 0;
          posts[postIndex].likedBy = [];
        }

        const alreadyLiked = posts[postIndex].likedBy.includes(CURRENT_USER_ID);

        if (alreadyLiked) {
          posts[postIndex].likes--;
          posts[postIndex].likedBy = posts[postIndex].likedBy.filter(
            (id) => id !== CURRENT_USER_ID
          );
        } else {
          posts[postIndex].likes++;
          posts[postIndex].likedBy.push(CURRENT_USER_ID);
        }

        localStorage.setItem("posts_" + topicId, JSON.stringify(posts));
        return {
          likes: posts[postIndex].likes,
          liked: !alreadyLiked,
        };
      }

      // Render post
      async function renderPost(topicId, postId) {
        const post = await getPost(topicId, postId);
        if (!post) {
          window.location.href = "topic.html?id=" + topicId;
          return;
        }

        // Set title and metadata
        document.getElementById("postTitle").textContent = post.title;
        document.getElementById("postAuthorName").textContent =
          post.author || "Anonymous";
        document.getElementById("postAuthorAvatar").textContent = getInitials(
          post.author
        );
        document.getElementById("postTime").textContent = formatRelativeTime(
          post.created
        );

        // Set post content with formatting
        document.getElementById("postContent").innerHTML =
          formatTextWithMarkdown(post.content);

        // Show edit indicator if needed
        if (post.lastEdited) {
          document.getElementById("postEditedContainer").style.display = "flex";
        }

        // Set likes count
        document.getElementById("likeCount").textContent = post.likes || 0;

        // Check if user already liked this post
        if (post.likedBy && post.likedBy.includes(CURRENT_USER_ID)) {
          document.getElementById("likeBtn").classList.add("active");
        }

        // Update breadcrumbs
        const topic = await getTopic(topicId);
        if (topic) {
          document.getElementById("topicBreadcrumb").textContent = topic.title;
          document.getElementById(
            "topicBreadcrumb"
          ).href = `topic.html?id=${topicId}`;
        }
        document.getElementById("postBreadcrumb").textContent = post.title;
      }

      // Render comments recursively - improved with better nesting indicators
      function renderCommentTree(comments, parentId = null, level = 0) {
        let html = "";
        const filteredComments = comments.filter((c) => {
          if (parentId === null) return c.parentId == null;
          return c.parentId == parentId;
        });

        if (filteredComments.length === 0) return "";

        filteredComments.forEach((comment) => {
          const hasReplies = comments.some((c) => c.parentId === comment.id);
          const isOwnComment = comment.userId === CURRENT_USER_ID;
          const isDeleted = comment.isDeleted;
          const relativeTime = formatRelativeTime(comment.created);
          const commentInitials = getInitials(comment.author);
          
          // For deeply nested comments (level > 2), show who they're replying to
          let replyPathHtml = '';
          if (level > 2 && comment.parentId) {
            const parentComment = comments.find(c => c.id === comment.parentId);
            if (parentComment) {
              replyPathHtml = `<div class="reply-path">
                <i class="bi bi-arrow-return-right"></i> 
                Replying to <strong>@${parentComment.author}</strong>
              </div>`;
            }
          }

          html += `
          <div class="comment" data-comment-id="${comment.id}" data-nesting-level="${level}">
            <div class="comment-header">
              <div class="comment-author-info">
                <div class="comment-avatar">${commentInitials}</div>
                <div class="comment-user">
                  <div class="comment-author">${comment.author}</div>
                  <div class="comment-meta">
                    ${relativeTime}
                    ${
                      comment.lastEdited
                        ? `<span class="edited-indicator">(edited)</span>`
                        : ""
                    }
                  </div>
                </div>
              </div>
            </div>
            
            <div class="comment-body">
              ${replyPathHtml}
              <div class="comment-content ${
                isDeleted ? "comment-deleted" : ""
              }">
                ${
                  isDeleted
                    ? comment.content
                    : formatTextWithMarkdown(comment.content)
                }
              </div>
              
              ${
                !isDeleted
                  ? `
                <div class="comment-actions">
                  <button class="reply-btn" onclick="showInlineReplyForm('${
                    comment.id
                  }', '${comment.author.replace(/'/g, "&#39;")}')">
                    <i class="bi bi-reply"></i> Reply
                  </button>
                  
                  ${
                    isOwnComment
                      ? `
                    <button class="edit-btn" onclick="editComment('${comment.id}')">
                      <i class="bi bi-pencil"></i> Edit
                    </button>
                    <button class="delete-btn" onclick="deleteComment('${comment.id}')">
                      <i class="bi bi-trash"></i> Delete
                    </button>
                  `
                      : ""
                  }
                  
                  ${
                    hasReplies
                      ? `
                    <button class="collapse-btn" onclick="toggleReplies('${comment.id}')">
                      <i class="bi bi-chevron-down toggle-icon"></i>
                      <span class="toggle-text">Show replies</span>
                    </button>
                  `
                      : ""
                  }
                </div>

                <!-- Inline reply form -->
                <div class="reply-form" id="replyForm-${comment.id}">
                  <div class="comment-avatar">${CURRENT_USER_INITIALS}</div>
                  <div style="flex: 1">
                    <div class="replying-to">
                      <i class="bi bi-reply"></i> 
                      Replying to @${comment.author}
                    </div>
                    <textarea class="reply-input" id="replyInput-${comment.id}" placeholder="Write your reply to @${comment.author}..."></textarea>
                    <div class="reply-btn-group">
                      <button class="reply-cancel" onclick="cancelReply('${comment.id}')">Cancel</button>
                      <button class="reply-submit" onclick="submitReply('${comment.id}')">Post Reply</button>
                    </div>
                  </div>
                </div>
              `
                  : ""
              }
              
              ${
                hasReplies
                  ? `<div class="comment-replies" id="replies-${
                      comment.id
                    }">${renderCommentTree(comments, comment.id, level + 1)}</div>`
                  : ""
              }
            </div>
          </div>
        `;
        });

        return html;
      }

      // Toggle comment replies - updated to track state
      window.toggleReplies = function (commentId) {
        const repliesContainer = document.getElementById(
          `replies-${commentId}`
        );
        const commentElement = repliesContainer.closest(".comment");
        const toggleBtn = commentElement.querySelector(".collapse-btn");
        const toggleIcon = toggleBtn.querySelector(".toggle-icon");
        const toggleText = toggleBtn.querySelector(".toggle-text");

        repliesContainer.style.display =
          repliesContainer.style.display === "none" ? "block" : "none";

        if (repliesContainer.style.display === "none") {
          toggleIcon.classList.remove("bi-chevron-up");
          toggleIcon.classList.add("bi-chevron-down");
          toggleText.textContent = "Show replies";
          expandedThreads.delete(commentId); // Remove from expanded threads
        } else {
          toggleIcon.classList.remove("bi-chevron-down");
          toggleIcon.classList.add("bi-chevron-up");
          toggleText.textContent = "Hide replies";
          expandedThreads.add(commentId); // Add to expanded threads
        }
      };

      // Show inline reply form
      window.showInlineReplyForm = function(commentId, author) {
        // Hide any active reply form first
        if (activeReplyForm) {
          activeReplyForm.classList.remove('active');
        }
        
        // Show the reply form for this comment
        const replyForm = document.getElementById(`replyForm-${commentId}`);
        replyForm.classList.add('active');
        
        // Focus the textarea
        const replyInput = document.getElementById(`replyInput-${commentId}`);
        replyInput.focus();
        
        // Update active form tracker
        activeReplyForm = replyForm;
      };

      // Cancel reply
      window.cancelReply = function(commentId) {
        const replyForm = document.getElementById(`replyForm-${commentId}`);
        replyForm.classList.remove('active');
        document.getElementById(`replyInput-${commentId}`).value = '';
        activeReplyForm = null;
      };

      // Submit reply - fixed version
      window.submitReply = async function(commentId) {
        const replyInput = document.getElementById(`replyInput-${commentId}`);
        const content = replyInput.value.trim();
        
        if (content) {
          // Save scroll position before any changes
          lastScrollPosition = window.scrollY;
          
          // Remember which threads are expanded
          document.querySelectorAll('.comment-replies').forEach(thread => {
            if (thread.style.display !== 'none') {
              const parentComment = thread.closest('.comment');
              if (parentComment) {
                const parentId = parentComment.dataset.commentId;
                expandedThreads.add(parentId);
              }
            }
          });
          
          // Always ensure the current thread will be expanded
          expandedThreads.add(commentId);
          
          const { topicId, postId } = getIdsFromUrl();
          
          await createComment(topicId, postId, {
            content: content,
            author: CURRENT_USER_NAME,
            parentId: commentId
          });

          // Clear the reply form
          replyInput.value = '';
          document.getElementById(`replyForm-${commentId}`).classList.remove('active');
          activeReplyForm = null;
          
          // Refresh comments
          await renderComments(topicId, postId);
          
          // After rendering, restore scroll position
          window.scrollTo({
            top: lastScrollPosition,
            behavior: 'auto'
          });
        }
      };

      // Edit a comment - fixed version
      window.editComment = async function (commentId) {
        // Save scroll position and expanded threads
        lastScrollPosition = window.scrollY;
        document.querySelectorAll('.comment-replies').forEach(thread => {
          if (thread.style.display !== 'none') {
            const parentComment = thread.closest('.comment');
            if (parentComment) {
              const parentId = parentComment.dataset.commentId;
              expandedThreads.add(parentId);
            }
          }
        });
        
        const { topicId, postId } = getIdsFromUrl();
        const commentsKey = "comments_" + topicId + "_" + postId;
        const comments = JSON.parse(localStorage.getItem(commentsKey) || "[]");
        const comment = comments.find((c) => c.id === commentId);

        if (!comment) return;

        const newContent = prompt("Edit your comment:", comment.content);
        if (newContent !== null && newContent.trim() !== "") {
          // Call updateCommentContent instead of editComment to avoid recursion
          await updateCommentContent(topicId, postId, commentId, newContent.trim());
          
          // Refresh comments and restore state
          await renderComments(topicId, postId);
          
          // Restore scroll position
          window.scrollTo({
            top: lastScrollPosition,
            behavior: 'auto'
          });
        }
      };

      // Delete a comment - fixed version
      window.deleteComment = async function (commentId) {
        // Save scroll position and expanded threads
        lastScrollPosition = window.scrollY;
        document.querySelectorAll('.comment-replies').forEach(thread => {
          if (thread.style.display !== 'none') {
            const parentComment = thread.closest('.comment');
            if (parentComment) {
              const parentId = parentComment.dataset.commentId;
              expandedThreads.add(parentId);
            }
          }
        });
        
        const { topicId, postId } = getIdsFromUrl();
        if (confirm("Are you sure you want to delete this comment?")) {
          // Call removeComment instead of deleteComment to avoid recursion
          await removeComment(topicId, postId, commentId);
          
          // Refresh comments and restore state
          await renderComments(topicId, postId);
          
          // Restore scroll position
          window.scrollTo({
            top: lastScrollPosition,
            behavior: 'auto'
          });
        }
      };

      // Quick comment functionality
      document
        .getElementById("quickCommentInput")
        .addEventListener("keydown", function (e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            document.getElementById("createCommentBtn").click();
          }
        });

      // Add comment button
      document.getElementById("createCommentBtn").onclick = async function () {
        const quickComment = document
          .getElementById("quickCommentInput")
          .value.trim();

        if (quickComment) {
          // Save thread state
          lastScrollPosition = window.scrollY;
          document.querySelectorAll('.comment-replies').forEach(thread => {
            if (thread.style.display !== 'none') {
              const parentComment = thread.closest('.comment');
              if (parentComment) {
                const parentId = parentComment.dataset.commentId;
                expandedThreads.add(parentId);
              }
            }
          });
          
          const { topicId, postId } = getIdsFromUrl();
          
          await createComment(topicId, postId, {
            content: quickComment,
            author: CURRENT_USER_NAME
          });

          document.getElementById("quickCommentInput").value = "";
          
          // Refresh with state preservation
          await renderComments(topicId, postId);
          
          // Scroll to bottom to see new comment
          window.scrollTo({
            top: document.body.scrollHeight,
            behavior: 'smooth'
          });
        }
      };

      // Render all comments - updated to maintain thread state
      async function renderComments(topicId, postId) {
        const commentsSort = document.getElementById(
          "commentSortDropdown"
        ).value;
        const comments = await getComments(topicId, postId, commentsSort);
        const commentsList = document.getElementById("commentsList");
        const commentsCount = document.getElementById("commentsCount");

        if (!comments || comments.length === 0) {
          commentsList.innerHTML = `
      <div class="empty-comments">
        <div class="empty-icon"><i class="bi bi-chat-square"></i></div>
        <div class="empty-text">No comments yet. Be the first to comment!</div>
      </div>
      `;
          commentsCount.textContent = "";
        } else {
          commentsList.innerHTML = renderCommentTree(comments);
          commentsCount.textContent = `(${comments.length})`;

          // Set thread visibility based on previously expanded state
          expandedThreads.forEach(threadId => {
            const repliesContainer = document.getElementById(`replies-${threadId}`);
            if (repliesContainer) {
              repliesContainer.style.display = 'block';
              
              // Update the button UI as well
              const commentElement = repliesContainer.closest('.comment');
              if (commentElement) {
                const toggleBtn = commentElement.querySelector('.collapse-btn');
                                if (toggleBtn) {
                  const toggleIcon = toggleBtn.querySelector('.toggle-icon');
                  const toggleText = toggleBtn.querySelector('.toggle-text');
                  
                  toggleIcon.classList.remove('bi-chevron-down');
                  toggleIcon.classList.add('bi-chevron-up');
                  toggleText.textContent = 'Hide replies';
                }
              }
            }
          });
          
          // If it's the first load, collapse all threads by default
          if (expandedThreads.size === 0) {
            const replyThreads = document.querySelectorAll(".comment-replies");
            replyThreads.forEach((thread) => {
              thread.style.display = "none";
            });
          }
        }
      }

      // Handle comment sorting
      document
        .getElementById("commentSortDropdown")
        .addEventListener("change", async function () {
          // Save state before sorting
          lastScrollPosition = window.scrollY;
          document.querySelectorAll('.comment-replies').forEach(thread => {
            if (thread.style.display !== 'none') {
              const parentComment = thread.closest('.comment');
              if (parentComment) {
                const parentId = parentComment.dataset.commentId;
                expandedThreads.add(parentId);
              }
            }
          });
          
          const { topicId, postId } = getIdsFromUrl();
          await renderComments(topicId, postId);
          
          // Restore scroll position after sorting
          window.scrollTo({
            top: lastScrollPosition,
            behavior: 'auto'
          });
        });

      // Handle likes
      document
        .getElementById("likeBtn")
        .addEventListener("click", async function () {
          const { topicId, postId } = getIdsFromUrl();
          const result = await likePost(topicId, postId);

          if (result) {
            document.getElementById("likeCount").textContent = result.likes;
            if (result.liked) {
              this.classList.add("active");
            } else {
              this.classList.remove("active");
            }
          }
        });

      // Back to topic link
      document.getElementById("backToTopic").onclick = async function () {
        const { topicId } = getIdsFromUrl();
        window.location.href = "topic.html?id=" + topicId;
      };

      // Initial page load
      (async function () {
        // Initialize theme system
        initializeTheme();

        const { topicId, postId } = getIdsFromUrl();
        if (!topicId || !postId) {
          window.location.href = "discussion.html";
          return;
        }

        // Set user information
        document.getElementById("sidebarUsername").textContent = CURRENT_USER_NAME;
        document.getElementById("sidebarUserAvatar").textContent = CURRENT_USER_INITIALS;
        document.getElementById("currentUserAvatar").textContent = CURRENT_USER_INITIALS;

        // Render post content
        await renderPost(topicId, postId);

        // Render comments
        await renderComments(topicId, postId);
      })();
    </script>
  </body>
</html>